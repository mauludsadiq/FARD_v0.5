import("std/float") as float
import("std/linalg") as linalg
import("std/list") as list
import("std/hash") as hash
import("std/json") as json

// ── float helpers ──────────────────────────────────────────────────────────
fn flt(x)      { float.from_int(x) }
fn ftxt(x)     { float.to_text(x) }
fn fadd(a, b)  { float.add(a, b) }
fn fmul(a, b)  { float.mul(a, b) }
fn fdiv(a, b)  { float.div(a, b) }
fn fsub(a, b)  { float.sub(a, b) }
fn fsqrt(x)    { float.sqrt(x) }
fn fabs(x)     { float.abs(x) }
fn fln(x)      { float.ln(x) }
fn fpow(b, e)  { float.pow(b, e) }
fn fneg(x)     { float.neg(x) }
fn fle(a, b)   { float.le(a, b) }
fn fgt(a, b)   { float.gt(a, b) }
fn flt2(a, b)  { float.lt(a, b) }

// ── Acklam rational approximation — accurate to 1e-9 ─────────────────────
fn normal_quantile(p) {
  let a0 = -39.69683028665376
  let a1 = 220.9460984245205
  let a2 = -275.9285104469687
  let a3 = 138.3577518672690
  let a4 = -30.66479806614716
  let a5 = 2.506628277459239
  let b0 = -54.47609879822406
  let b1 = 161.5858368580409
  let b2 = -155.6989798598866
  let b3 = 66.80131188771972
  let b4 = -13.28068155288572
  let c0 = -0.007784894002430293
  let c1 = -0.3223964580411365
  let c2 = -2.400758277161838
  let c3 = -2.549732539343734
  let c4 = 4.374664141464968
  let c5 = 2.938163982698783
  let d0 = 0.007784695709041462
  let d1 = 0.3224671290700398
  let d2 = 2.445134137142996
  let d3 = 3.754408661907416
  let p_low  = 0.02425
  let p_high = 0.97575
  let in_mid = if fle(p_low, p) then fle(p, p_high) else false
  let q_mid  = fsub(p, 0.5)
  let r_mid  = fmul(q_mid, q_mid)
  let num_m  = fmul(q_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, a0), a1)), a2)), a3)), a4)), a5))
  let den_m  = fadd(fmul(r_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, fadd(fmul(r_mid, b0), b1)), b2)), b3)), b4)), 1.0)
  let mid    = fdiv(num_m, den_m)
  let q_tail = if fgt(p, p_high) then fsqrt(fmul(2.0, fneg(fln(fsub(1.0, p))))) else fsqrt(fmul(2.0, fneg(fln(p))))
  let num_t  = fadd(fmul(q_tail, fadd(fmul(q_tail, fadd(fmul(q_tail, fadd(fmul(q_tail, fadd(fmul(q_tail, c0), c1)), c2)), c3)), c4)), c5)
  let den_t  = fadd(fmul(q_tail, fadd(fmul(q_tail, fadd(fmul(q_tail, fadd(fmul(q_tail, d0), d1)), d2)), d3)), 1.0)
  let tail_pos = fdiv(num_t, den_t)
  let tail   = if fgt(p, p_high) then fneg(tail_pos) else tail_pos
  if in_mid then mid else tail
}

fn chi2_quantile(df, p) {
  let z    = normal_quantile(p)
  let df_f = float.from_int(df)
  let x    = fdiv(2.0, fmul(9.0, df_f))
  let term = fadd(fsub(1.0, x), fmul(z, fsqrt(x)))
  fmul(df_f, fpow(term, 3.0))
}

// ── build N×N covariance matrix from weights, vols, corr matrix ───────────
// positions: list of {price, shares, vol} records
// corr:      N×N correlation matrix (list of rows, each row list of floats)
// returns:   list of rows (covariance matrix scaled by 1/sqrt(252))
fn build_cov(positions, corr) {
  let sq252 = fsqrt(252.0)
  let n = list.len(positions)
  list.map(
    list.range(0, n),
    fn(i) {
      let vi = positions[i].vol
      list.map(
        list.range(0, n),
        fn(j) {
          let vj = positions[j].vol
          fdiv(fmul(fmul(vi, vj), corr[i][j]), sq252)
        }
      )
    }
  )
}

// ── N-asset quadratic form w^T Sigma w ────────────────────────────────────
fn quad_form(w, sigma) {
  let sw = linalg.matvec(sigma, w)
  linalg.dot(w, sw)
}

// ── risk check ────────────────────────────────────────────────────────────
fn risk_check(positions, corr, total_value, max_var_frac, var_pct) {
  let n     = list.len(positions)
  let w     = list.map(positions, fn(p) { fmul(p.price, p.shares) })
  let sigma = build_cov(positions, corr)
  let quad  = quad_form(w, sigma)
  let chi2  = chi2_quantile(n, var_pct)
  let var_bound = fmul(fsqrt(chi2), fsqrt(fabs(quad)))
  let threshold = fmul(total_value, max_var_frac)
  { ok: fle(var_bound, threshold), var_bound: var_bound,
    threshold: threshold, quad: quad, chi2: chi2 }
}

// ── liquidity check ───────────────────────────────────────────────────────
fn liq_one(price, shares, adv, beta, days, hs, ki, ai) {
  let q      = fabs(shares)
  let cap    = fmul(fmul(beta, adv), days)
  let qcap   = if flt2(q, cap) then q else cap
  let spread = fmul(fmul(price, hs), qcap)
  let a1     = fadd(ai, 1.0)
  let impact = fmul(fmul(price, fdiv(ki, a1)), fpow(qcap, a1))
  fadd(spread, impact)
}

fn liq_check(positions, adv, beta, days, hs, ki, ai, total_value, max_frac) {
  let costs = list.map(positions,
    fn(p) { liq_one(p.price, p.shares, adv, beta, days, hs, ki, ai) })
  let total_cost = list.fold(costs, 0.0, fn(acc, c) { fadd(acc, c) })
  let frac = fdiv(total_cost, total_value)
  { ok: fle(frac, max_frac), total_cost: total_cost, cost_fraction: frac }
}

// ── leverage check ────────────────────────────────────────────────────────
fn lev_check(positions, equity, max_lev, quad, chi2) {
  let gross    = list.fold(positions, 0.0,
                   fn(acc, p) { fadd(acc, fabs(fmul(p.price, p.shares))) })
  let loss_wc  = fmul(fsqrt(chi2), fsqrt(fabs(quad)))
  let headroom = fsub(equity, fdiv(gross, max_lev))
  let ok       = if fgt(headroom, 0.0) then fle(loss_wc, headroom) else false
  { ok: ok, loss_wc: loss_wc, headroom: headroom,
    gross: gross, current_lev: fdiv(gross, equity) }
}

// ── portfolio digest ──────────────────────────────────────────────────────
fn portfolio_digest(total_value, equity, n) {
  let j = json.encode({ total_value: ftxt(total_value), equity: ftxt(equity), n: n })
  hash.sha256_text(j)
}

// ── Portfolio: AAPL x10 @ 170.5, MSFT x5 @ 350.0, GOOG x2 @ 140.0 ───────
let positions = [
  { price: 170.5, shares: 10.0, vol: 0.25 },
  { price: 350.0, shares:  5.0, vol: 0.30 },
  { price: 140.0, shares:  2.0, vol: 0.20 }
]

// 3×3 correlation matrix
let corr = [
  [1.0, 0.6, 0.4],
  [0.6, 1.0, 0.5],
  [0.4, 0.5, 1.0]
]

let total_value = list.fold(positions, 0.0,
  fn(acc, p) { fadd(acc, fmul(p.price, p.shares)) })
let equity = fdiv(total_value, 2.0)

let adv  = 1000000.0
let beta = 0.1
let days = 5.0
let hs   = 0.0005
let ki   = 0.1
let ai   = 0.6

let risk = risk_check(positions, corr, total_value, 0.02, 0.95)
let liq  = liq_check(positions, adv, beta, days, hs, ki, ai, total_value, 0.01)
let lev  = lev_check(positions, equity, 3.0, risk.quad, risk.chi2)
let overall = if risk.ok then if liq.ok then lev.ok else false else false
let digest  = portfolio_digest(total_value, equity, list.len(positions))

{
  n_positions:   list.len(positions),
  total_value:   ftxt(total_value),
  equity:        ftxt(equity),
  portfolio_digest: digest,
  risk: {
    ok:        risk.ok,
    var_bound: ftxt(risk.var_bound),
    threshold: ftxt(risk.threshold),
    quad_form: ftxt(risk.quad),
    chi2_radius: ftxt(risk.chi2)
  },
  liquidity: {
    ok:           liq.ok,
    total_cost:   ftxt(liq.total_cost),
    cost_fraction: ftxt(liq.cost_fraction)
  },
  leverage: {
    ok:          lev.ok,
    loss_wc:     ftxt(lev.loss_wc),
    headroom:    ftxt(lev.headroom),
    gross:       ftxt(lev.gross),
    current_lev: ftxt(lev.current_lev)
  },
  overall_verdict: overall
}
