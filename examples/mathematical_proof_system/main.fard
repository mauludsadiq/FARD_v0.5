module mathematical_proof_system

fn gcd(a: Int, b: Int) : Int
  if eq(b, 0) { a }
  else { gcd(b, rem(a, b)) }

fn abs_int(n: Int) : Int
  if lt(n, 0) { neg(n) } else { n }

fn lcm(a: Int, b: Int) : Int
  div(mul(abs_int(a), abs_int(b)), gcd(abs_int(a), abs_int(b)))

fn ext_gcd(a: Int, b: Int) : Value
  if eq(b, 0)
    {g: a, x: 1, y: 0}
  else
    let r = ext_gcd(b, rem(a, b))
    let g = map_get(r, "g")
    let x = map_get(r, "x")
    let y = map_get(r, "y")
    {g: g, x: y, y: sub(x, mul(div(a, b), y))}

fn is_prime(n: Int) : Bool
  if lt(n, 2) { false }
  else { prime_check(n, 2) }

fn prime_check(n: Int, d: Int) : Bool
  if gt(mul(d, d), n) { true }
  else if eq(rem(n, d), 0) { false }
  else { prime_check(n, add(d, 1)) }

fn factorize(n: Int) : Value
  factorize_from(n, 2, [])

fn factorize_from(n: Int, d: Int, acc: Value) : Value
  if lt(n, 2) { acc }
  else if eq(rem(n, d), 0) { factorize_from(div(n, d), d, list_append(acc, d)) }
  else { factorize_from(n, add(d, 1), acc) }

fn product(xs: Value) : Int
  product_loop(xs, 0, 1)

fn product_loop(xs: Value, i: Int, acc: Int) : Int
  if eq(i, list_len(xs)) { acc }
  else { product_loop(xs, add(i, 1), mul(acc, list_get(xs, i))) }

fn all_prime(xs: Value, i: Int) : Bool
  if eq(i, list_len(xs)) { true }
  else if eq(is_prime(list_get(xs, i)), false) { false }
  else { all_prime(xs, add(i, 1)) }

fn euclid_lemma_check(p: Int, a: Int, b: Int) : Bool
  if eq(is_prime(p), false) { true }
  else if eq(rem(mul(a, b), p), 0)
    if eq(rem(a, p), 0) { true }
    else { eq(rem(b, p), 0) }
  else { true }

fn euclid_sweep(p: Int, a: Int, b: Int, acc: Bool) : Bool
  if gt(p, 20) { acc }
  else if gt(a, 10) { euclid_sweep(add(p, 1), 1, 1, acc) }
  else if gt(b, 10) { euclid_sweep(p, add(a, 1), 1, acc) }
  else
    let ok = euclid_lemma_check(p, a, b)
    euclid_sweep(p, a, add(b, 1), if eq(ok, false) { false } else { acc })

fn verify_euclid_lemma() : Value
  let result = euclid_sweep(2, 1, 1, true)
  {theorem: "Euclid's Lemma", verified: result, statement: "if p|ab then p|a or p|b"}

fn verify_bezout(a: Int, b: Int) : Bool
  let r = ext_gcd(a, b)
  let g = map_get(r, "g")
  let x = map_get(r, "x")
  let y = map_get(r, "y")
  eq(add(mul(a, x), mul(b, y)), g)

fn bezout_sweep(a: Int, b: Int, acc: Bool) : Bool
  if gt(a, 20) { acc }
  else if gt(b, 20) { bezout_sweep(add(a, 1), 1, acc) }
  else
    let ok = verify_bezout(a, b)
    bezout_sweep(a, add(b, 1), if eq(ok, false) { false } else { acc })

fn verify_bezout_identity() : Value
  let result = bezout_sweep(1, 1, true)
  {theorem: "Bezout's Identity", verified: result,
   statement: "gcd(a,b) = ax + by", example: ext_gcd(12, 8)}

fn verify_factorization_existence(n: Int) : Bool
  if lt(n, 2) { true }
  else
    let factors = factorize(n)
    if eq(list_len(factors), 0) { false }
    else if eq(product(factors), n) { all_prime(factors, 0) }
    else { false }

fn existence_sweep(n: Int, max: Int, acc: Bool) : Bool
  if gt(n, max) { acc }
  else
    let ok = verify_factorization_existence(n)
    existence_sweep(add(n, 1), max, if eq(ok, false) { false } else { acc })

fn verify_prime_factorization_existence() : Value
  let result = existence_sweep(2, 100, true)
  {theorem: "Prime Factorization Existence", verified: result,
   statement: "every n in [2,100] factors into primes", example: factorize(60)}

fn uniqueness_sweep(n: Int, max: Int, acc: Bool) : Bool
  if gt(n, max) { acc }
  else
    let ok = eq(product(factorize(n)), n)
    uniqueness_sweep(add(n, 1), max, if eq(ok, false) { false } else { acc })

fn verify_fta_uniqueness() : Value
  let result = uniqueness_sweep(2, 100, true)
  {theorem: "FTA Uniqueness", verified: result,
   statement: "product(factorize(n)) = n for all n in [2,100]"}

fn verify_gcd_lcm_product(a: Int, b: Int) : Bool
  if eq(a, 0) { true }
  else if eq(b, 0) { true }
  else { eq(mul(gcd(a, b), lcm(a, b)), mul(abs_int(a), abs_int(b))) }

fn gcd_lcm_sweep(a: Int, b: Int, acc: Bool) : Bool
  if gt(a, 20) { acc }
  else if gt(b, 20) { gcd_lcm_sweep(add(a, 1), 1, acc) }
  else
    let ok = verify_gcd_lcm_product(a, b)
    gcd_lcm_sweep(a, add(b, 1), if eq(ok, false) { false } else { acc })

fn verify_gcd_lcm() : Value
  let result = gcd_lcm_sweep(1, 1, true)
  {theorem: "gcd * lcm = a * b", verified: result,
   statement: "gcd(a,b) * lcm(a,b) = a*b for a,b in [1,20]",
   example: {a: 12, b: 18, gcd: gcd(12, 18), lcm: lcm(12, 18)}}

fn main() : Value {
  let t1 = verify_euclid_lemma()
  let t2 = verify_bezout_identity()
  let t3 = verify_prime_factorization_existence()
  let t4 = verify_fta_uniqueness()
  let t5 = verify_gcd_lcm()
  let all_pass = if eq(map_get(t1, "verified"), true)
    if eq(map_get(t2, "verified"), true)
      if eq(map_get(t3, "verified"), true)
        if eq(map_get(t4, "verified"), true)
          { eq(map_get(t5, "verified"), true) }
        else { false }
      else { false }
    else { false }
  else { false }
  {theorems: [t1, t2, t3, t4, t5], all_verified: all_pass}
}
