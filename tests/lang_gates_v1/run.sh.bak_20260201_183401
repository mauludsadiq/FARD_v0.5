OUT_ROOT="tests/lang_gates_v1/out"
LOCK_DEFAULT="fard.lock.json"

pass_ct=0
fail_ct=0

ok()   { printf 'PASS %s\n' "$1"; pass_ct=$((pass_ct+1)); }
fail() { printf 'FAIL %s\n' "$1"; fail_ct=$((fail_ct+1)); }

mkdir -p "$OUT_ROOT"

FARD_RUN() {
  cargo run --quiet --bin fardrun -- "$@"
}

lock_opt() {
  lock_path="${LOCK:-$LOCK_DEFAULT}"
  if [ -f "$lock_path" ]; then
    printf '%s' "--lock $lock_path"
  else
    printf '%s' ""
  fi
}

# Try both CLI shapes:
#   (A) fardrun run <prog> --out <dir> [--lock ...]
#   (B) fardrun <prog> --out <dir> [--lock ...]
run_prog() {
  prog="$1"
  out="$2"

  rm -rf "$out"
  mkdir -p "$out"

  lo="$(lock_opt)"

  FARD_RUN run "$prog" --out "$out" $lo >/dev/null 2>"$out/stderr.txt"
  code=$?

  if [ $code -eq 0 ]; then
    return 0
  fi

  # retry positional form
  FARD_RUN "$prog" --out "$out" $lo >/dev/null 2>"$out/stderr.txt"
  return $?
}

ndjson_lint() {
  f="$1"
  [ -f "$f" ] || return 1
  awk 'NF{print}' "$f" | while IFS= read -r line; do
    printf '%s\n' "$line" | jq -e . >/dev/null 2>/dev/null || exit 1
  done
}

has() { [ -f "$1" ]; }
grepq() { rg -n "$1" "$2" >/dev/null 2>/dev/null; }

gate_G0() {
  v="$(FARD_RUN --version 2>/dev/null)"
  if [ -z "$v" ]; then
    v="$(FARD_RUN version 2>/dev/null)"
  fi
  printf '%s\n' "$v" | rg -n 'fard_runtime_version=' >/dev/null 2>/dev/null || return 1
  printf '%s\n' "$v" | rg -n 'trace_format_version=' >/dev/null 2>/dev/null || return 1
  printf '%s\n' "$v" | rg -n 'stdlib_root_cid=' >/dev/null 2>/dev/null || return 1
}

gate_G1() {
  a="$OUT_ROOT/g1a"
  b="$OUT_ROOT/g1b"
  run_prog "tests/gate/programs/g07_determinism_twice_same_trace.fard" "$a" || return 1
  run_prog "tests/gate/programs/g07_determinism_twice_same_trace.fard" "$b" || return 1
  has "$a/trace.ndjson" || return 1
  has "$b/trace.ndjson" || return 1
  cmp "$a/trace.ndjson" "$b/trace.ndjson" >/dev/null 2>/dev/null || return 1
  if has "$a/result.json" && has "$b/result.json"; then
    cmp "$a/result.json" "$b/result.json" >/dev/null 2>/dev/null || return 1
  fi
}

gate_G2() {
  out="$OUT_ROOT/g2"
  run_prog "tests/gate/programs/g03_trace_parseable.fard" "$out" || return 1
  has "$out/trace.ndjson" || return 1
  ndjson_lint "$out/trace.ndjson" || return 1
}

gate_G3() {
  out="$OUT_ROOT/g3b"
  rm -rf "$out"
  mkdir -p "$out"

  # This one intentionally uses the mismatch lock shipped in the test folder.
  lo="--lock tests/gate/programs/g09_lock_mismatch/fard.lock.json"

  FARD_RUN run "tests/gate/programs/g09_lock_mismatch/main.fard" --out "$out" $lo >/dev/null 2>"$out/stderr.txt"
  code=$?
  if [ $code -eq 0 ]; then
    FARD_RUN "tests/gate/programs/g09_lock_mismatch/main.fard" --out "$out" $lo >/dev/null 2>"$out/stderr.txt"
    code=$?
  fi

  [ $code -ne 0 ] || return 1
  grepq 'LOCK_MISMATCH' "$out/stderr.txt" || return 1
}

gate_G4() {
  out="$OUT_ROOT/g4"
  run_prog "tests/gate/programs/g08_import_cycle/main.fard" "$out" || true
  # cycle gate expects non-zero exit + IMPORT_CYCLE marker
  code=0
  if run_prog "tests/gate/programs/g08_import_cycle/main.fard" "$out"; then
    code=0
  else
    code=1
  fi
  [ $code -ne 0 ] || return 1
  grepq 'IMPORT_CYCLE' "$out/stderr.txt" || return 1
}

run_one() {
  name="$1"
  fn="$2"
  "$fn"
  if [ $? -eq 0 ]; then ok "$name"; else fail "$name"; fi
}

run_one "G0_distribution_identity" gate_G0
run_one "G1_determinism_trace_bytes" gate_G1
run_one "G2_trace_parseable_ndjson" gate_G2
run_one "G3_lock_mismatch_diagnostics" gate_G3
run_one "G4_import_cycle_diagnostics" gate_G4

printf 'GATE_V1_SUMMARY passed=%s failed=%s\n' "$pass_ct" "$fail_ct"
if [ "$fail_ct" -eq 0 ]; then exit 0; fi
exit 1
