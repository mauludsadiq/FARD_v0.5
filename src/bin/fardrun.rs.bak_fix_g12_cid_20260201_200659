use anyhow::{anyhow, bail, Context, Result};
use serde_json::{Map, Value as J};
use sha2::{Digest, Sha256};
use std::collections::{BTreeMap, HashMap};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() -> Result<()> {
  let args: Vec<String> = std::env::args().collect();
  if args.len() >= 2 && (args[1] == "--version" || args[1] == "-V") {
    println!("fard_runtime_version={}", env!("CARGO_PKG_VERSION"));
    println!("trace_format_version=0.1.0");
    println!("stdlib_root_cid=sha256:dev");
    return Ok(());
  }
    let mut args: Vec<String> = std::env::args().skip(1).collect();
    if args.first().map(|s| s.as_str()) == Some("run") {
        args.remove(0);
    }

    let mut program: Option<PathBuf> = None;
    let mut out_dir: Option<PathBuf> = None;
    let mut lockfile: Option<PathBuf> = None;

    let mut i = 0usize;
    while i < args.len() {
        let a = args[i].clone();
        if a == "--program" {
            i += 1;
            if i >= args.len() {
                bail!("--program missing value");
            }
            program = Some(PathBuf::from(&args[i]));
        } else if let Some(v) = a.strip_prefix("--program=") {
            program = Some(PathBuf::from(v));
        } else if a == "--out" {
            i += 1;
            if i >= args.len() {
                bail!("--out missing value");
            }
            out_dir = Some(PathBuf::from(&args[i]));
        } else if let Some(v) = a.strip_prefix("--out=") {
            out_dir = Some(PathBuf::from(v));
        } else if a == "--lockfile" || a == "--lock" {
            i += 1;
            if i >= args.len() {
                bail!("--lockfile missing value");
            }
            lockfile = Some(PathBuf::from(&args[i]));
        } else if let Some(v) = a.strip_prefix("--lockfile=") {
            lockfile = Some(PathBuf::from(v));
        } else if !a.starts_with("-") && program.is_none() {
            program = Some(PathBuf::from(&a));
        }
        i += 1;
    }

    let program = program.context("missing --program")?;
    let out_dir = out_dir.context("missing --out")?;

    fs::create_dir_all(&out_dir).ok();

    let trace_path = out_dir.join("trace.ndjson");
    let result_path = out_dir.join("result.json");

    let mut tracer = Tracer::new(&out_dir, &trace_path)?;
    let mut loader = ModuleLoader::new(program.parent().unwrap_or(Path::new(".")));

    if let Some(lockp) = lockfile {
        loader.lock = Some(Lockfile::load(&lockp)?);
    }

    let v = match loader.eval_main(&program, &mut tracer) {
            Ok(v) => v,
            Err(e) => {
                let msg0 = format!("{}", e);
                let code = msg0.split_whitespace().find(|w| w.starts_with("ERROR_" )).unwrap_or("ERROR_RUNTIME").to_string();
                let msg = if msg0.contains("ERROR_") { msg0 } else { format!("ERROR_RUNTIME {}", msg0) };
                let mut em = Map::new();
                em.insert("code".to_string(), J::String(code.clone()));
                em.insert("message".to_string(), J::String(msg.clone()));
                fs::write(out_dir.join("error.json"), serde_json::to_vec(&J::Object(em))?)?;
                tracer.error_event(&code, &msg).ok();
                bail!(msg);
            }
        };
    let j = v.to_json().context("final result must be jsonable")?;
    let mut root = Map::new();
    root.insert("result".to_string(), j);
    fs::write(&result_path, serde_json::to_vec(&J::Object(root))?)?;
    Ok(())
}

struct Tracer {
    w: fs::File,
    out_dir: PathBuf,
}
impl Tracer {
    fn new(out_dir: &Path, path: &Path) -> Result<Self> {
        fs::create_dir_all(out_dir).ok();
        fs::create_dir_all(out_dir.join("artifacts")).ok();
        let w = fs::File::create(path)?;
        Ok(Self { w, out_dir: out_dir.to_path_buf() })
    }

    fn emit(&mut self, v: &J) -> Result<()> {
        let mut m = Map::new();
        m.insert("t".to_string(), J::String("emit".to_string()));
        m.insert("v".to_string(), v.clone());
        let line = serde_json::to_string(&J::Object(m))?;
        self.w.write_all(line.as_bytes())?;
        self.w.write_all(b"\n")?;
        Ok(())
    }

    fn grow_node(&mut self, v: &Val) -> Result<()> {
        let j = v.to_json().context("grow_node must be jsonable")?;
        let mut m = Map::new();
        m.insert("t".to_string(), J::String("grow_node".to_string()));
        m.insert("v".to_string(), j);
        let line = serde_json::to_string(&J::Object(m))?;
        self.w.write_all(line.as_bytes())?;
        self.w.write_all(b"\n")?;
        Ok(())
    }

    fn artifact_in(&mut self, path: &str, cid: &str) -> Result<()> {
        let mut m = Map::new();
        m.insert("t".to_string(), J::String("artifact_in".to_string()));
        m.insert("path".to_string(), J::String(path.to_string()));
        m.insert("cid".to_string(), J::String(cid.to_string()));
        let line = serde_json::to_string(&J::Object(m))?;
        self.w.write_all(line.as_bytes())?;
        self.w.write_all(b"\n")?;
        Ok(())
    }

    fn artifact_out(&mut self, name: &str, cid: &str, bytes: &[u8]) -> Result<()> {
        let outp = self.out_dir.join("artifacts").join(name);
        fs::write(&outp, bytes)?;
        {
        let cid_path = if let Some(ext) = outp.extension().and_then(|e| e.to_str()) {
            outp.with_extension(format!("{ext}.cid"))
        } else {
            outp.with_extension("cid")
        };
        fs::write(&cid_path, format!("{}\n", cid))?;
    }
        let mut m = Map::new();
        m.insert("t".to_string(), J::String("artifact_out".to_string()));
        m.insert("name".to_string(), J::String(name.to_string()));
        m.insert("cid".to_string(), J::String(cid.to_string()));
        let line = serde_json::to_string(&J::Object(m))?;
        self.w.write_all(line.as_bytes())?;
        self.w.write_all(b"\n")?;
        Ok(())
    }

    fn error_event(&mut self, code: &str, message: &str) -> Result<()> {
        let mut m = Map::new();
        m.insert("t".to_string(), J::String("error".to_string()));
        m.insert("code".to_string(), J::String(code.to_string()));
        m.insert("message".to_string(), J::String(message.to_string()));
        let line = serde_json::to_string(&J::Object(m))?;
        self.w.write_all(line.as_bytes())?;
        self.w.write_all(b"\n")?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
enum Tok {
    Kw(String),
    Ident(String),
    Num(i64),
    Str(String),
    Sym(String),
    Eof,
}

fn is_ident_start(c: char) -> bool {
    c.is_ascii_alphabetic() || c == '_'
}
fn is_ident_cont(c: char) -> bool {
    c.is_ascii_alphanumeric() || c == '_'
}

struct Lex {
    s: Vec<char>,
    i: usize,
}
impl Lex {
    fn new(src: &str) -> Self {
        Self {
            s: src.chars().collect(),
            i: 0,
        }
    }
    fn peek(&self) -> Option<char> {
        self.s.get(self.i).copied()
    }
    fn bump(&mut self) -> Option<char> {
        let c = self.peek()?;
        self.i += 1;
        Some(c)
    }
    fn skip_ws(&mut self) {
        while let Some(c) = self.peek() {
            if c.is_whitespace() {
                self.i += 1;
                continue;
            }
            if c == '/' && self.s.get(self.i + 1) == Some(&'/') {
                while let Some(d) = self.peek() {
                    self.i += 1;
                    if d == '\n' {
                        break;
                    }
                }
                continue;
            }
            break;
        }
    }
    fn next(&mut self) -> Result<Tok> {
        self.skip_ws();
        let Some(c) = self.peek() else {
            return Ok(Tok::Eof);
        };

        if is_ident_start(c) {
            let mut t = String::new();
            t.push(self.bump().unwrap());
            while let Some(d) = self.peek() {
                if is_ident_cont(d) {
                    t.push(self.bump().unwrap());
                } else {
                    break;
                }
            }
            {
                let id = t;
                let kws = [
                    "let", "in", "fn", "if", "then", "else", "import", "as", "export", "true",
                    "false", "null",
                ];
                if kws.contains(&id.as_str()) {
                    return Ok(Tok::Kw(id));
                }
                return Ok(Tok::Ident(id));
            }
        }

        if c.is_ascii_digit() {
            let mut n: i64 = 0;
            while let Some(d) = self.peek() {
                if d.is_ascii_digit() {
                    n = n * 10 + (d as i64 - '0' as i64);
                    self.i += 1;
                } else {
                    break;
                }
            }
            return Ok(Tok::Num(n));
        }

        if c == '"' {
            self.bump();
            let mut t = String::new();
            while let Some(d) = self.bump() {
                if d == '"' {
                    break;
                }
                if d == '\\' {
                    let e = self.bump().ok_or_else(|| anyhow!("bad escape"))?;
                    match e {
                        'n' => t.push('\n'),
                        't' => t.push('\t'),
                        '"' => t.push('"'),
                        '\\' => t.push('\\'),
                        _ => bail!("bad escape: \\{e}"),
                    }
                } else {
                    t.push(d);
                }
            }
            return Ok(Tok::Str(t));
        }

        let two = if self.i + 1 < self.s.len() {
            let mut t = String::new();
            t.push(self.s[self.i]);
            t.push(self.s[self.i + 1]);
            Some(t)
        } else {
            None
        };

        for op in ["==", "<=", ">=", "&&", "||"] {
            if two.as_deref() == Some(op) {
                self.i += 2;
                return Ok(Tok::Sym(op.to_string()));
            }
        }

        let one = self.bump().unwrap();
        let sym = match one {
            '(' | ')' | '{' | '}' | '[' | ']' | ',' | ':' | '.' | '+' | '-' | '*' | '/' | '=' => {
                one.to_string()
            }
            _ => bail!("unexpected char: {one}"),
        };
        Ok(Tok::Sym(sym))
    }
}

#[derive(Clone, Debug)]
enum Expr {
    Let(String, Box<Expr>, Box<Expr>),
    If(Box<Expr>, Box<Expr>, Box<Expr>),
    Fn(Vec<String>, Box<Expr>),
    Call(Box<Expr>, Vec<Expr>),
    Get(Box<Expr>, String),
    List(Vec<Expr>),
    Rec(Vec<(String, Expr)>),
    Var(String),
    Int(i64),
    Bool(bool),
    Str(String),
    Null,
    Bin(String, Box<Expr>, Box<Expr>),
    Unary(String, Box<Expr>),
}

#[derive(Clone, Debug)]
enum Item {
    Import(String, String),
    Let(String, Expr),
    Fn(String, Vec<String>, Expr),
    Export(Vec<String>),
    Expr(Expr),
}

struct Parser {
    toks: Vec<Tok>,
    i: usize,
}
impl Parser {
    fn from_src(src: &str) -> Result<Self> {
        let mut lx = Lex::new(src);
        let mut toks = Vec::new();
        loop {
            let t = lx.next()?;
            let done = matches!(t, Tok::Eof);
            toks.push(t);
            if done {
                break;
            }
        }
        Ok(Self { toks, i: 0 })
    }
    fn peek(&self) -> &Tok {
        self.toks.get(self.i).unwrap_or(&Tok::Eof)
    }
    fn bump(&mut self) -> Tok {
        let t = self.peek().clone();
        self.i += 1;
        t
    }
    fn eat_sym(&mut self, s: &str) -> bool {
        matches!(self.peek(), Tok::Sym(x) if x == s) && {
            self.i += 1;
            true
        }
    }
    fn expect_sym(&mut self, s: &str) -> Result<()> {
        if self.eat_sym(s) {
            Ok(())
        } else {
            bail!("expected symbol {s:?}")
        }
    }
    fn eat_kw(&mut self, s: &str) -> bool {
        if matches!(self.peek(), Tok::Kw(x) if x == s)
            || matches!(self.peek(), Tok::Ident(x) if x == s)
        {
            self.i += 1;
            true
        } else {
            false
        }
    }
    fn expect_kw(&mut self, s: &str) -> Result<()> {
        if self.eat_kw(s) {
            Ok(())
        } else {
            bail!("expected keyword {s}")
        }
    }
    fn expect_ident(&mut self) -> Result<String> {
        match self.bump() {
            Tok::Ident(x) => Ok(x),
            _ => bail!("expected identifier"),
        }
    }

    fn parse_module(&mut self) -> Result<Vec<Item>> {
        let mut items = Vec::new();
        while !matches!(self.peek(), Tok::Eof) {
            if self.eat_kw("import") {
                self.expect_sym("(")?;
                let p = match self.bump() {
                    Tok::Str(s) => s,
                    _ => bail!("import() requires string"),
                };
                self.expect_sym(")")?;
                self.expect_kw("as")?;
                let alias = self.expect_ident()?;
                items.push(Item::Import(p, alias));
                continue;
            }
            if self.eat_kw("export") {
                self.expect_sym("{")?;
                let mut names = Vec::new();
                loop {
                    let n = self.expect_ident()?;
                    names.push(n);
                    if self.eat_sym("}") {
                        break;
                    }
                    self.expect_sym(",")?;
                    if self.eat_sym("}") {
                        break;
                    }
                }
                items.push(Item::Export(names));
                continue;
            }
            if self.eat_kw("fn") {
                let name = self.expect_ident()?;
                self.expect_sym("(")?;
                let mut params = Vec::new();
                if !self.eat_sym(")") {
                    loop {
                        let p = self.expect_ident()?;
                        params.push(p);
                        if self.eat_sym(")") {
                            break;
                        }
                        self.expect_sym(",")?;
                        if self.eat_sym(")") {
                            break;
                        }
                    }
                }
                self.expect_sym("{")?;
                let body = self.parse_expr()?;
                self.expect_sym("}")?;
                items.push(Item::Fn(name, params, body));
                continue;
            }
            if self.eat_kw("let") {
                let name = self.expect_ident()?;
                self.expect_sym("=")?;
                let rhs = self.parse_expr()?;
                items.push(Item::Let(name, rhs));
                continue;
            }
            let e = self.parse_expr()?;
            items.push(Item::Expr(e));
            break;
        }
        Ok(items)
    }

    fn parse_expr(&mut self) -> Result<Expr> {
        if self.eat_kw("let") {
            let name = self.expect_ident()?;
            self.expect_sym("=")?;
            let e1 = self.parse_expr()?;
            self.expect_kw("in")?;
            let e2 = self.parse_expr()?;
            return Ok(Expr::Let(name, Box::new(e1), Box::new(e2)));
        }
        if self.eat_kw("if") {
            let c = self.parse_expr()?;
            self.expect_kw("then")?;
            let t = self.parse_expr()?;
            self.expect_kw("else")?;
            let f = self.parse_expr()?;
            return Ok(Expr::If(Box::new(c), Box::new(t), Box::new(f)));
        }
        self.parse_or()
    }

    fn parse_or(&mut self) -> Result<Expr> {
        let mut e = self.parse_and()?;
        while self.eat_sym("||") {
            let r = self.parse_and()?;
            e = Expr::Bin("||".to_string(), Box::new(e), Box::new(r));
        }
        Ok(e)
    }
    fn parse_and(&mut self) -> Result<Expr> {
        let mut e = self.parse_eq()?;
        while self.eat_sym("&&") {
            let r = self.parse_eq()?;
            e = Expr::Bin("&&".to_string(), Box::new(e), Box::new(r));
        }
        Ok(e)
    }
    fn parse_eq(&mut self) -> Result<Expr> {
        let mut e = self.parse_add()?;
        while self.eat_sym("==") {
            let r = self.parse_add()?;
            e = Expr::Bin("==".to_string(), Box::new(e), Box::new(r));
        }
        Ok(e)
    }
    fn parse_add(&mut self) -> Result<Expr> {
        let mut e = self.parse_mul()?;
        loop {
            if self.eat_sym("+") {
                let r = self.parse_mul()?;
                e = Expr::Bin("+".to_string(), Box::new(e), Box::new(r));
            } else if self.eat_sym("-") {
                let r = self.parse_mul()?;
                e = Expr::Bin("-".to_string(), Box::new(e), Box::new(r));
            } else {
                break;
            }
        }
        Ok(e)
    }
    fn parse_mul(&mut self) -> Result<Expr> {
        let mut e = self.parse_unary()?;
        loop {
            if self.eat_sym("*") {
                let r = self.parse_unary()?;
                e = Expr::Bin("*".to_string(), Box::new(e), Box::new(r));
            } else if self.eat_sym("/") {
                let r = self.parse_unary()?;
                e = Expr::Bin("/".to_string(), Box::new(e), Box::new(r));
            } else {
                break;
            }
        }
        Ok(e)
    }
    fn parse_unary(&mut self) -> Result<Expr> {
        if self.eat_sym("-") {
            let e = self.parse_unary()?;
            return Ok(Expr::Unary("-".to_string(), Box::new(e)));
        }
        self.parse_postfix()
    }
    fn parse_postfix(&mut self) -> Result<Expr> {
        let mut e = self.parse_primary()?;
        loop {
            if self.eat_sym(".") {
                let n = self.expect_ident()?;
                e = Expr::Get(Box::new(e), n);
                continue;
            }
            if self.eat_sym("(") {
                let mut args = Vec::new();
                if !self.eat_sym(")") {
                    loop {
                        let a = self.parse_expr()?;
                        args.push(a);
                        if self.eat_sym(")") {
                            break;
                        }
                        self.expect_sym(",")?;
                        if self.eat_sym(")") {
                            break;
                        }
                    }
                }
                e = Expr::Call(Box::new(e), args);
                continue;
            }
            break;
        }
        Ok(e)
    }
    fn parse_primary(&mut self) -> Result<Expr> {
        if self.eat_kw("fn") {
            self.expect_sym("(")?;
            let mut params = Vec::new();
            if !self.eat_sym(")") {
                loop {
                    let p = self.expect_ident()?;
                    params.push(p);
                    if self.eat_sym(")") {
                        break;
                    }
                    self.expect_sym(",")?;
                    if self.eat_sym(")") {
                        break;
                    }
                }
            }
            self.expect_sym("{")?;
            let body = self.parse_expr()?;
            self.expect_sym("}")?;
            return Ok(Expr::Fn(params, Box::new(body)));
        }

        match self.bump() {
            Tok::Num(n) => Ok(Expr::Int(n)),
            Tok::Str(s) => Ok(Expr::Str(s)),
            Tok::Kw(s) if s == "true" => Ok(Expr::Bool(true)),
            Tok::Kw(s) if s == "false" => Ok(Expr::Bool(false)),
            Tok::Kw(s) if s == "null" => Ok(Expr::Null),
            Tok::Ident(s) => Ok(Expr::Var(s)),
            Tok::Sym(s) if s == "(" => {
                let e = self.parse_expr()?;
                self.expect_sym(")")?;
                Ok(e)
            }
            Tok::Sym(s) if s == "[" => {
                let mut xs = Vec::new();
                if !self.eat_sym("]") {
                    loop {
                        xs.push(self.parse_expr()?);
                        if self.eat_sym("]") {
                            break;
                        }
                        self.expect_sym(",")?;
                        if self.eat_sym("]") {
                            break;
                        }
                    }
                }
                Ok(Expr::List(xs))
            }
            Tok::Sym(s) if s == "{" => {
                let mut kvs = Vec::new();
                if !self.eat_sym("}") {
                    loop {
                        let k = match self.bump() {
                            Tok::Ident(x) => x,
                            Tok::Kw(x) => x,
                            Tok::Str(x) => x,
                            _ => bail!("record key must be ident or string"),
                        };
                        self.expect_sym(":")?;
                        let v = self.parse_expr()?;
                        kvs.push((k, v));
                        if self.eat_sym("}") {
                            break;
                        }
                        self.expect_sym(",")?;
                        if self.eat_sym("}") {
                            break;
                        }
                    }
                }
                Ok(Expr::Rec(kvs))
            }
            other => bail!("unexpected token: {other:?}"),
        }
    }
}

#[derive(Clone, Debug)]
enum Val {
    Int(i64),
    Bool(bool),
    Str(String),
    Null,
    List(Vec<Val>),
    Rec(BTreeMap<String, Val>),
    Func(Func),
    Builtin(Builtin),
}
#[derive(Clone, Debug)]
struct Func {
    params: Vec<String>,
    body: Expr,
    env: Env,
}
#[derive(Clone, Debug)]
enum Builtin {
    ListGet,
    ListSortByIntKey,
    GrowUnfoldTree,
    ImportArtifact,
    EmitArtifact,

    Emit,
    Len,
    SortInt,
    DedupeSortedInt,
    HistInt,
    Unfold,
}

#[derive(Clone, Debug)]
struct Env {
    parent: Option<Box<Env>>,
    vars: HashMap<String, Val>,
}
impl Env {
    fn new() -> Self {
        Self {
            parent: None,
            vars: HashMap::new(),
        }
    }
    fn child(&self) -> Self {
        Self {
            parent: Some(Box::new(self.clone())),
            vars: HashMap::new(),
        }
    }
    fn set(&mut self, k: String, v: Val) {
        self.vars.insert(k, v);
    }
    fn get(&self, k: &str) -> Option<Val> {
        if let Some(v) = self.vars.get(k) {
            return Some(v.clone());
        }
        self.parent.as_ref().and_then(|p| p.get(k))
    }
}

impl Val {
    fn to_json(&self) -> Option<J> {
        match self {
            Val::Int(n) => Some(J::Number((*n).into())),
            Val::Bool(b) => Some(J::Bool(*b)),
            Val::Str(s) => Some(J::String(s.clone())),
            Val::Null => Some(J::Null),
            Val::List(xs) => Some(J::Array(
                xs.iter().map(|x| x.to_json()).collect::<Option<Vec<_>>>()?,
            )),
            Val::Rec(m) => {
                let mut obj = Map::new();
                for (k, v) in m.iter() {
                    obj.insert(k.clone(), v.to_json()?);
                }
                Some(J::Object(obj))
            }
            Val::Func(_) | Val::Builtin(_) => None,
        }
    }
}

fn eval(e: &Expr, env: &mut Env, tracer: &mut Tracer, loader: &mut ModuleLoader) -> Result<Val> {
    match e {
        Expr::Int(n) => Ok(Val::Int(*n)),
        Expr::Bool(b) => Ok(Val::Bool(*b)),
        Expr::Str(s) => Ok(Val::Str(s.clone())),
        Expr::Null => Ok(Val::Null),
        Expr::Var(n) => env.get(n).ok_or_else(|| anyhow!("unbound var: {n}")),
        Expr::List(xs) => {
            let mut out = Vec::new();
            for x in xs {
                out.push(eval(x, env, tracer, loader)?);
            }
            Ok(Val::List(out))
        }
        Expr::Rec(kvs) => {
            let mut m = BTreeMap::new();
            for (k, v) in kvs {
                m.insert(k.clone(), eval(v, env, tracer, loader)?);
            }
            Ok(Val::Rec(m))
        }
        Expr::Get(obj, k) => {
            let o = eval(obj, env, tracer, loader)?;
            match o {
                Val::Rec(m) => m
                    .get(k)
                    .cloned()
                    .ok_or_else(|| anyhow!("missing field {k}")),
                _ => bail!("field access on non-record"),
            }
        }
        Expr::Let(name, e1, e2) => {
            let v1 = eval(e1, env, tracer, loader)?;
            let mut child = env.child();
            child.set(name.clone(), v1);
            eval(e2, &mut child, tracer, loader)
        }
        Expr::If(c, t, f) => {
            let cv = eval(c, env, tracer, loader)?;
            match cv {
                Val::Bool(true) => eval(t, env, tracer, loader),
                Val::Bool(false) => eval(f, env, tracer, loader),
                _ => bail!("if cond must be bool"),
            }
        }
        Expr::Fn(params, body) => Ok(Val::Func(Func {
            params: params.clone(),
            body: (*body.clone()),
            env: env.clone(),
        })),
        Expr::Unary(op, a) => {
            let v = eval(a, env, tracer, loader)?;
            match (op.as_str(), v) {
                ("-", Val::Int(n)) => Ok(Val::Int(-n)),
                _ => bail!("bad unary op"),
            }
        }
        Expr::Bin(op, a, b) => {
            let x = eval(a, env, tracer, loader)?;
            let y = eval(b, env, tracer, loader)?;
            match (op.as_str(), x, y) {
                ("+", Val::Int(l), Val::Int(r)) => Ok(Val::Int(l + r)),
                ("-", Val::Int(l), Val::Int(r)) => Ok(Val::Int(l - r)),
                ("*", Val::Int(l), Val::Int(r)) => Ok(Val::Int(l * r)),
                ("/", Val::Int(l), Val::Int(r)) => Ok(Val::Int(l / r)),
                ("==", l, r) => Ok(Val::Bool(val_eq(&l, &r))),
                ("&&", Val::Bool(l), Val::Bool(r)) => Ok(Val::Bool(l && r)),
                ("||", Val::Bool(l), Val::Bool(r)) => Ok(Val::Bool(l || r)),
                _ => bail!("bad binop {op}"),
            }
        }
        Expr::Call(f, args) => {
            let fv = eval(f, env, tracer, loader)?;
            let mut av = Vec::new();
            for a in args {
                av.push(eval(a, env, tracer, loader)?);
            }
            call(fv, av, tracer, loader)
        }
    }
}

fn val_eq(a: &Val, b: &Val) -> bool {
    match (a, b) {
        (Val::Int(x), Val::Int(y)) => x == y,
        (Val::Bool(x), Val::Bool(y)) => x == y,
        (Val::Str(x), Val::Str(y)) => x == y,
        (Val::Null, Val::Null) => true,
        (Val::List(xs), Val::List(ys)) => {
            xs.len() == ys.len() && xs.iter().zip(ys).all(|(x, y)| val_eq(x, y))
        }
        (Val::Rec(xm), Val::Rec(ym)) => {
            xm.len() == ym.len()
                && xm
                    .iter()
                    .all(|(k, xv)| ym.get(k).map(|yv| val_eq(xv, yv)).unwrap_or(false))
        }
        _ => false,
    }
}

fn call(f: Val, args: Vec<Val>, tracer: &mut Tracer, loader: &mut ModuleLoader) -> Result<Val> {
    match f {
        Val::Builtin(b) => call_builtin(b, args, tracer, loader),
        Val::Func(fun) => {
            if fun.params.len() != args.len() {
                bail!("arity mismatch");
            }
            let mut e = fun.env.child();
            for (p, a) in fun.params.iter().zip(args.into_iter()) {
                e.set(p.clone(), a);
            }
            eval(&fun.body, &mut e, tracer, loader)
        }
        _ => bail!("call on non-function"),
    }
}

fn call_builtin(
    b: Builtin,
    args: Vec<Val>,
    tracer: &mut Tracer,
    loader: &mut ModuleLoader,
) -> Result<Val> {
    match b {
        Builtin::ListGet => {
            if args.len() != 2 { bail!("ERROR_BADARG list.get expects 2 args"); }
            let xs = match &args[0] { Val::List(v) => v.clone(), _ => bail!("ERROR_BADARG list.get arg0 must be list") };
            let i = match &args[1] { Val::Int(n) => *n, _ => bail!("ERROR_BADARG list.get arg1 must be int") };
            if i < 0 { bail!("ERROR_OOB list index out of bounds"); }
            let iu = i as usize;
            if iu >= xs.len() { bail!("ERROR_OOB list index out of bounds"); }
            return Ok(xs[iu].clone());
        }

        Builtin::ListSortByIntKey => {
            if args.len() != 2 { bail!("ERROR_BADARG sort_by_int_key expects 2 args"); }
            let xs = match &args[0] { Val::List(v) => v.clone(), _ => bail!("ERROR_BADARG sort_by_int_key arg0 must be list") };
            let mut keyed: Vec<(i64, usize, Val)> = Vec::new();
            for (idx, it) in xs.into_iter().enumerate() {
                let k = match &it {
                    Val::Rec(m) => match m.get("k") { Some(Val::Int(n)) => *n, _ => bail!("ERROR_BADARG sort_by_int_key expects rec.k int") },
                    _ => bail!("ERROR_BADARG sort_by_int_key expects records")
                };
                keyed.push((k, idx, it));
            }
            keyed.sort_by(|a,b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)));
            let out: Vec<Val> = keyed.into_iter().map(|t| t.2).collect();
            return Ok(Val::List(out));
        }

        Builtin::GrowUnfoldTree => {
            if args.len() < 2 { bail!("ERROR_BADARG unfold_tree expects at least 2 args"); }
            let seed = args[0].clone();
            let depth = match &args[1] {
                Val::Rec(m) => match m.get("depth") { Some(Val::Int(n)) => *n, _ => 2 },
                _ => 2
            };
            let mut q: std::collections::VecDeque<(Val,i64)> = std::collections::VecDeque::new();
            q.push_back((seed.clone(), 0));
            while let Some((node, d)) = q.pop_front() {
                tracer.grow_node(&node)?;
                if d >= depth { continue; }
                let n = match &node {
                    Val::Rec(m) => match m.get("n") { Some(Val::Int(x)) => *x, _ => 0 },
                    _ => 0
                };
                let c1 = Val::Rec({ let mut m = BTreeMap::new(); m.insert("n".to_string(), Val::Int(n+1)); m });
                let c2 = Val::Rec({ let mut m = BTreeMap::new(); m.insert("n".to_string(), Val::Int(n+2)); m });
                q.push_back((c1, d+1));
                q.push_back((c2, d+1));
            }
            return Ok(Val::Null);
        }

        Builtin::ImportArtifact => {
            if args.len() != 1 { bail!("ERROR_BADARG import_artifact expects 1 arg"); }
            let p = match &args[0] { Val::Str(s) => s.clone(), _ => bail!("ERROR_BADARG import_artifact arg must be string") };
            let bytes = fs::read(&p).with_context(|| format!("ERROR_IO cannot read artifact: {p}"))?;
            let cid = sha256_bytes(&bytes);
            tracer.artifact_in(&p, &cid)?;
            let out: Vec<Val> = bytes.into_iter().map(|b| Val::Int(b as i64)).collect();
            return Ok(Val::List(out));
        }

        Builtin::EmitArtifact => {
            if args.len() != 2 { bail!("ERROR_BADARG emit_artifact expects 2 args"); }
            let name = match &args[0] { Val::Str(s) => s.clone(), _ => bail!("ERROR_BADARG emit_artifact name must be string") };
            let xs = match &args[1] { Val::List(v) => v.clone(), _ => bail!("ERROR_BADARG emit_artifact bytes must be list") };
            let mut bytes: Vec<u8> = Vec::with_capacity(xs.len());
            for v in xs {
                let n = match v { Val::Int(i) => i, _ => bail!("ERROR_BADARG emit_artifact bytes must be ints") };
                if n < 0 || n > 255 { bail!("ERROR_BADARG emit_artifact byte out of range"); }
                bytes.push(n as u8);
            }
            let cid = sha256_bytes(&bytes);
            tracer.artifact_out(&name, &cid, &bytes)?;
            return Ok(Val::Null);
        }
        Builtin::Emit => {
            if args.len() != 1 {
                bail!("emit arity");
            }
            let j = args[0]
                .to_json()
                .ok_or_else(|| anyhow!("emit arg must be jsonable"))?;
            tracer.emit(&j)?;
            Ok(Val::Null)
        }
        Builtin::Len => {
            if args.len() != 1 {
                bail!("len arity");
            }
            match &args[0] {
                Val::List(xs) => Ok(Val::Int(xs.len() as i64)),
                _ => bail!("len expects list"),
            }
        }
        Builtin::SortInt => {
            if args.len() != 1 {
                bail!("sort_int arity");
            }
            let mut xs = match args[0].clone() {
                Val::List(v) => v,
                _ => bail!("sort_int expects list"),
            };
            let mut ns: Vec<i64> = Vec::new();
            for v in xs.drain(..) {
                match v {
                    Val::Int(n) => ns.push(n),
                    _ => bail!("sort_int expects ints"),
                }
            }
            insertion_sort(&mut ns);
            Ok(Val::List(ns.into_iter().map(Val::Int).collect()))
        }
        Builtin::DedupeSortedInt => {
            if args.len() != 1 {
                bail!("dedupe_sorted_int arity");
            }
            let xs = match args[0].clone() {
                Val::List(v) => v,
                _ => bail!("dedupe_sorted_int expects list"),
            };
            let mut out: Vec<i64> = Vec::new();
            let mut last: Option<i64> = None;
            for v in xs {
                let n = match v {
                    Val::Int(n) => n,
                    _ => bail!("dedupe_sorted_int expects ints"),
                };
                if last.map(|x| x == n).unwrap_or(false) {
                    continue;
                }
                last = Some(n);
                out.push(n);
            }
            Ok(Val::List(out.into_iter().map(Val::Int).collect()))
        }
        Builtin::HistInt => {
            if args.len() != 1 {
                bail!("hist_int arity");
            }
            let xs = match args[0].clone() {
                Val::List(v) => v,
                _ => bail!("hist_int expects list"),
            };

            let mut m: BTreeMap<i64, i64> = BTreeMap::new();
            for v in xs {
                let n = match v {
                    Val::Int(n) => n,
                    _ => bail!("hist_int expects ints"),
                };
                *m.entry(n).or_insert(0) += 1;
            }

            let mut out_list: Vec<Val> = Vec::new();
            for (v, c) in m {
                let mut rec = BTreeMap::new();
                rec.insert("v".to_string(), Val::Int(v));
                rec.insert("count".to_string(), Val::Int(c));
                out_list.push(Val::Rec(rec));
            }
            Ok(Val::List(out_list))
        }
        Builtin::Unfold => {
            if args.len() != 3 {
                bail!("unfold arity");
            }
            let mut seed = args[0].clone();
            let fuel = match args[1] {
                Val::Int(n) => n,
                _ => bail!("unfold fuel must be int"),
            };
            let step = args[2].clone();

            let mut out = Vec::new();
            let mut k = 0i64;
            while k < fuel {
                let r = call(step.clone(), vec![seed.clone()], tracer, loader)?;
                match r {
                    Val::Null => break,
                    Val::Rec(m) => {
                        let next_seed = m
                            .get("seed")
                            .cloned()
                            .ok_or_else(|| anyhow!("unfold step missing seed"))?;
                        let val = m
                            .get("value")
                            .cloned()
                            .ok_or_else(|| anyhow!("unfold step missing value"))?;
                        out.push(val);
                        seed = next_seed;
                    }
                    _ => bail!("unfold step must return record or null"),
                }
                k += 1;
            }
            Ok(Val::List(out))
        }
    }
}

fn insertion_sort(xs: &mut [i64]) {
    for i in 1..xs.len() {
        let key = xs[i];
        let mut j = i;
        while j > 0 && xs[j - 1] > key {
            xs[j] = xs[j - 1];
            j -= 1;
        }
        xs[j] = key;
    }
}

struct Lockfile {
    modules: HashMap<String, String>,
}
impl Lockfile {
    fn load(p: &Path) -> Result<Self> {
        let v: J = serde_json::from_slice(&fs::read(p)?)?;
        let mut modules = HashMap::new();
        if let Some(ms) = v.get("modules").and_then(|x| x.as_object()) {
            for (k, vv) in ms {
                let dig = vv
                    .get("digest")
                    .and_then(|x| x.as_str())
                    .unwrap_or("")
                    .to_string();
                modules.insert(k.clone(), dig);
            }
        }
        Ok(Self { modules })
    }
    fn expected(&self, k: &str) -> Option<&str> {
        self.modules.get(k).map(|s| s.as_str())
    }
}

struct ModuleLoader {
    root_dir: PathBuf,
    cache: HashMap<String, BTreeMap<String, Val>>,
    stack: Vec<String>,
    lock: Option<Lockfile>,
}
impl ModuleLoader {
    fn new(root: &Path) -> Self {
        Self {
            root_dir: root.to_path_buf(),
            cache: HashMap::new(),
            stack: Vec::new(),
            lock: None,
        }
    }

    fn eval_main(&mut self, main_path: &Path, tracer: &mut Tracer) -> Result<Val> {
        let src = fs::read_to_string(main_path)?;
        let mut p = Parser::from_src(&src)?;
        let items = p.parse_module()?;
        let mut env = base_env();
        let here_dir = main_path
            .parent()
            .map(|p| p.to_path_buf())
            .unwrap_or_else(|| self.root_dir.clone());
        self.eval_items(items, &mut env, tracer, &here_dir)
    }

    fn eval_items(
        &mut self,
        items: Vec<Item>,
        env: &mut Env,
        tracer: &mut Tracer,
        here: &Path,
    ) -> Result<Val> {
        let mut exports: Option<Vec<String>> = None;
        let mut last: Val = Val::Null;

        for it in items {
            match it {
                Item::Import(path, alias) => {
                    let ex = self.load_module(&path, here, tracer)?;
                    env.set(alias, Val::Rec(ex));
                }
                Item::Let(name, rhs) => {
                    let v = eval(&rhs, env, tracer, self)?;
                    env.set(name, v);
                }
                Item::Fn(name, params, body) => {
                    let f = Val::Func(Func {
                        params,
                        body,
                        env: env.clone(),
                    });
                    env.set(name, f);
                }
                Item::Export(ns) => exports = Some(ns),
                Item::Expr(e) => last = eval(&e, env, tracer, self)?,
            }
        }

        if let Some(ns) = exports {
            let mut out = BTreeMap::new();
            for n in ns {
                let v = env
                    .get(&n)
                    .ok_or_else(|| anyhow!("export missing name: {n}"))?;
                out.insert(n, v);
            }
            return Ok(Val::Rec(out));
        }

        Ok(last)
    }

    fn load_module(
        &mut self,
        name: &str,
        here: &Path,
        tracer: &mut Tracer,
    ) -> Result<BTreeMap<String, Val>> {
        if let Some(c) = self.cache.get(name) {
            return Ok(c.clone());
        }

        if self.stack.contains(&name.to_string()) {
            bail!("IMPORT_CYCLE cycle detected in imports at {name}");
        }
        self.stack.push(name.to_string());

        let exports = if name.starts_with("std/") {
            let ex = self.builtin_std(name)?;
            self.check_lock(name, &self.builtin_digest(name))?;
            ex
        } else {
            let base: &Path = if name.starts_with("lib/") { self.root_dir.as_path() } else { here };

            let path = base.join(format!("{name}.fard"));
            let src = fs::read_to_string(&path)
                .with_context(|| format!("missing module file: {}", path.display()))?;
            self.check_lock(name, &file_digest(&path)?)?;

            let mut p = Parser::from_src(&src)?;
            let items = p.parse_module()?;
            let mut env = base_env();
            let v = self.eval_items(items, &mut env, tracer, path.parent().unwrap_or(here))?;
            match v {
                Val::Rec(m) => m,
                _ => bail!("module must export a record"),
            }
        };

        self.stack.pop();
        self.cache.insert(name.to_string(), exports.clone());
        Ok(exports)
    }

    fn check_lock(&self, module: &str, got: &str) -> Result<()> {
        if let Some(lk) = &self.lock {
            if let Some(exp) = lk.expected(module) {
                if exp != got {
                    bail!("LOCK_MISMATCH lock mismatch for module {module}: expected {exp}, got {got}");
                }
            }
        }
        Ok(())
    }

    fn builtin_std(&self, name: &str) -> Result<BTreeMap<String, Val>> {
        match name {
            "std/list" => {
                let mut m = BTreeMap::new();
                m.insert("get".to_string(), Val::Builtin(Builtin::ListGet));
                m.insert("sort_by_int_key".to_string(), Val::Builtin(Builtin::ListSortByIntKey));
                m.insert("sort_int".to_string(), Val::Builtin(Builtin::SortInt));
                m.insert(
                    "dedupe_sorted_int".to_string(),
                    Val::Builtin(Builtin::DedupeSortedInt),
                );
                m.insert("hist_int".to_string(), Val::Builtin(Builtin::HistInt));
                Ok(m)
            }
            "std/grow" => {
                let mut m = BTreeMap::new();
                m.insert("unfold_tree".to_string(), Val::Builtin(Builtin::GrowUnfoldTree));
                m.insert("unfold".to_string(), Val::Builtin(Builtin::Unfold));
                Ok(m)
            }
            _ => bail!("unknown std module: {name}"),
        }
    }

    fn builtin_digest(&self, name: &str) -> String {
        let mut h = Sha256::new();
        h.update(format!("builtin:{name}:v0.5").as_bytes());
        format!("sha256:{:x}", h.finalize())
    }
}

fn base_env() -> Env {
    let mut e = Env::new();
    e.set("emit".to_string(), Val::Builtin(Builtin::Emit));
    e.set("len".to_string(), Val::Builtin(Builtin::Len));
    e.set("import_artifact".to_string(), Val::Builtin(Builtin::ImportArtifact));
    e.set("emit_artifact".to_string(), Val::Builtin(Builtin::EmitArtifact));
    e.set("import_artifact".to_string(), Val::Builtin(Builtin::ImportArtifact));
    e.set("emit_artifact".to_string(), Val::Builtin(Builtin::EmitArtifact));
    e
}

fn sha256_bytes(bytes: &[u8]) -> String {
    let mut h = Sha256::new();
    h.update(bytes);
    format!("sha256:{}", hex::encode(h.finalize()))
}

fn file_digest(p: &Path) -> Result<String> {
    let b = fs::read(p)?;
    let mut h = Sha256::new();
    h.update(&b);
    Ok(format!("sha256:{:x}", h.finalize()))
}
