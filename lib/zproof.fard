import("std/hash") as hash
import("std/json") as json
import("std/str") as str

// ── genesis receipt (start of chain) ─────────────────────────────────────
fn genesis() {
  let zero = "0000000000000000000000000000000000000000000000000000000000000000"
  { prev_hash: zero, seq: 0, receipt_hash: zero }
}

// ── hash any value via JSON encoding ─────────────────────────────────────
fn val_hash(v) {
  hash.sha256_text(json.encode(v))
}

// ── strip sha256: prefix for chaining ────────────────────────────────────
fn strip_prefix(s) {
  if str.starts_with(s, "sha256:") then str.slice(s, 7, str.len(s)) else s
}

// ── create next receipt in chain ──────────────────────────────────────────
// prev:    previous receipt record (must have receipt_hash field)
// prog_id: string identifying the program/version
// inputs:  any value representing the inputs
// result:  any value representing the result
fn next(prev, prog_id, inputs, result) {
  let seq        = prev.seq + 1
  let prev_h     = strip_prefix(prev.receipt_hash)
  let prog_h     = strip_prefix(val_hash(prog_id))
  let inputs_h   = strip_prefix(val_hash(inputs))
  let result_h   = strip_prefix(val_hash(result))
  let body       = {
    prev_hash:    prev_h,
    seq:          seq,
    prog_id:      prog_id,
    prog_hash:    prog_h,
    inputs_hash:  inputs_h,
    result_hash:  result_h
  }
  let receipt_hash = val_hash(body)
  {
    prev_hash:    prev_h,
    seq:          seq,
    prog_id:      prog_id,
    prog_hash:    prog_h,
    inputs_hash:  inputs_h,
    result_hash:  result_h,
    receipt_hash: receipt_hash
  }
}

// ── verify a chain of receipts (list, oldest first) ───────────────────────
fn verify_chain(receipts) {
  import("std/list") as list
  let n = list.len(receipts)
  list.fold(
    list.range(1, n),
    true,
    fn(ok, i) {
      if ok then
        str.contains(receipts[i].prev_hash, strip_prefix(receipts[i - 1].receipt_hash))
      else false
    }
  )
}

{ genesis: genesis, next: next, verify_chain: verify_chain, val_hash: val_hash }
